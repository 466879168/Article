## SPA单页面的理解，以及优缺点
spa单页面应用是在页面加载初期就加载htmlcssjs，一旦页面加载完成，就利用路由机制实现html内容的切换，UI与用户的交互，避免重新加载  
优点：  
1. 用户体验好，内容加载快，内容的改变不需要重新加载整个网页，避免了不需要的跳转和渲染
2. SPA对服务器的压力比较小
3. 前后端职责分离，架构清晰，前端负责交互逻辑，后端负责数据处理

缺点：  
1. 初次加载时消耗的资源比较多，为了实现SPA，需要在页面加载的时候将JScss统一加载
2. 前进后退是由路由管理，所有的页面切换需要建立自己的堆栈管理
3. SEO难度较大，由于所有的内容都是在一个页面中动态的替换，所以SEO方面有着天生的劣势

## v-show 与 v-if 有什么区别？
1. v-if的元素显示与隐藏是通过元素的创建于销毁控制的
2. v-show的元素显示与隐藏是通过css属性display控制的
3. v-if是真正的条件渲染，因为在切换过程中条件块内的事件监听器和子组件会被销毁和重建，并且他是惰性的，如果初始条件为假，什么都不做，只有在第一次条件为真的时候才真正的渲染
4. v-show不管条件的真假，元素都是会渲染的
5. v-if有着更好的切换消耗，v-show有着更高的初始消耗
6. v-if适用于在运行时候很少改变条件的，不需要频繁的切换条件的场景，v-show则适用于非常频繁切换条件的场景

## computed 和 watch 的区别和运用的场景？
1. computed是计算属性，依赖于其他的属性值，并且计算属性有缓存效果，只有当他依赖的值发生变化，下一次使用的时候才会重新计算
2. watch更多的是观察者的作用，类似于某些数据的监听回调，每次监听的数据变化时都会执行回调函数进行操作
3. 当我们需要数值计算的时候，并且依赖于其他的数据，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值得时候，都要重新计算
4. 当我们需要在数据发生变化的时候执行异步操作的话，应该使用watch，因为他可以让我们执行异步操作，并在我们获得最终结果之前，设置中间状态

## computed 和 watch 的区别和运用的场景？
vue实例又一个完整的生命周期，从vue实例创建到初始化数据，编译模板，挂载dom，更新，销毁等一系列的过程我们称之为vue的生命周期  
+ beforecreate 组件实例创建之前
+ created组件实例已经创建完成
+ beforeMount在元素创建之前
+ mounted 在元素创建出来之后
+ beforeUpdate 组件数据更新之前
+ update 组件数据更新之后
+ activited keep-alive专属，组件被激活时调用
+ deactivated keep-alive专属，组件被销毁时调用
+ beforeDestory 组件销毁前调用
+ destoryed 组件销毁之后调用

## 谈谈你对 keep-alive 的了解？
keep-alive是vue的一个内置组件，可以使被包含的组件保留状态，避免被重新渲染，  
1. 一般结合路由和动态组件一起使用，用于缓存组件
2. 提供include和exclude属性，两者都支持字符串和正则匹配，include表示只有名称匹配的组件会缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude优先级比include高
3. 对应了两个钩子函数，activated 和 deactivated，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated

## 组件中 data 为什么是一个函数？
函数返回的是一个新对象，组件复用的时候保证每次都是新的对象，避免数据之间的互相影响

## Vue 组件间通信有哪几种方式？
1. 父组件通过bind将数据传递给子组件，子组件通过props接收数据，子组件通过emit传递数据出去，父组件通过v-on接收
2. $parent获取父组件$children获取子组件，获取到的子组件是一个数组，需要下标获取，或者用ref获取到指定的子组件
3. bus总线，通过一个空的vue实例作为事件中心，通过emit和on发射事件和触发事件
4. 通过vuex全局状态管理模式，每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )

## 你使用过 Vuex 吗？
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )
+ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新
+ 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化

1. State：定义了应用状态的数据结构，可以在这里设置默认的初始状态
2. Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性
3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数
4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作
5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中

## 使用过 Vue SSR 吗？说说 SSR？
使用vue默认是在浏览器中输出vuezujia进行生成dom和操作dom。也可以将一个vue组件渲染未服务器端的html字符串，将他们直接发送到浏览器

优点：  
1. 更好的SEO，因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面
2. 更快的加载速度： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间

缺点：  
1. 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境
2. 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源

## 什么是 MVVM？
MVVM是一个软件架构设计模式，View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，ViewModel 是由前端开发人员组织生成和维护的视图数据层  
MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。

## vue是如何的实现数据双向绑定
vue是通过defineproperty和发布订阅模式完成的，  
当vue实例创建之后：  
1. 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
2. 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新
3. 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数
4. 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理

## 虚拟 DOM 实现原理？
1. 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象
2. diff 算法 — 比较两棵虚拟 DOM 树的差异
3. pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树

## 虚拟 DOM 的优缺点？
1. 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限
2. 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率
3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等

缺点：  
1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化

## Vue 中的 key 有什么作用？
为元素添加唯一标识符，让diff更加的高效和迅速


