# 自己实现js的原生方法
## 1. 目录：
1. 冒泡排序
2. 插入排序
3. 快速排序
4. bind方法
5. 防抖函数（debounce）
6. 节流函数（throttle）
7. 深克隆（deepclone）
8. Event(event bus)
9. instanceOf
10. 模拟new
11. call
12. apply方法
13. bind
14. Object.create
15. 类的继承
16. JSON.parse
17. Promise
18. URL Params 为对象
19. 模板引擎
20. 转化为驼峰命名
21. 查找字符串中出现最多的字符和个数
22. 字符串查找
23. 实现千位分隔符
24. 是否是电话号码
25. 是否是邮箱
26. 是否是身份证


## 2. 冒泡排序
```javascript
/冒泡排序的思想：让数组中的当前项和后一项进行比较，如果当前项比后一项大，则两项交换位置
/**
 * bubble实现冒泡排序
 * @param arr 需要排序的数组
 * @return 排序后的新数组
 */
function bubble(arr) {
    //外层循环循环几次
    for (let i=0;i<arr.length-1;i++){
        //内层循环控制每一轮的次数
        for (let j=0;j<arr.length-1-i;j++){
            if (arr[j]>arr[j+1]){
                //当前项大于后一项
                temp=arr[j]
                arr[j]=arr[j+1]
                arr[j+1]=temp
            }
        }
    }
    return arr
}
```




## 3. 插入排序
```javascript
//插入排序
/**
 * insert插入排序
 * @param arr 需要排序的数组
 * @returns {*} 返回排序后的新数组
 */
function insert(arr) {
    //1. 准备一个新数组，用来存储抓到手里的牌，开始先抓一张牌进来
    let handle=[]
    handle.push(arr[0])
    //2. 从第二项开始一次抓牌，一直到把牌面上的牌抓光
    for (let i=1;i<arr.length;i++){
        //A是新抓的牌
        let A=arr[i]
        //和handle手里的牌一次比较（从后向前）
        for (let j=handle.length-1;j>=0;j--){
            //每一次要比较的手里的牌
            let B=handle[j]
            //如果当前新牌A比要比较的牌B大，把A放到B的后面
            if (A>B){
                handle.splice(j+1,0,A)
                break
            }
            //已经比到了第一项了，我们把新牌A放到最前面即可
            if (j === 0){
                handle.unshift(A)
            }
        }
    }
    return handle
}
```

## 4. 快速排序
```javascript
//[12,8,15,16,1,24]
//快速排序：找到数组的中间项，把她从原来数组中移除，获取这一项的结果（15）然后拿出数组中的每一项和中间项比较，小的放左边，大的放右边，左右两边继续这个操作
/**
 * quick 快速排序
 * @param arr 需要排序的数组
 * @return 排序后的数组
 */
function quick(arr) {
    //4. 结束递归，当arr中小于等于一项的时候，则不处理
    if (arr.length <= 1) {
        return arr
    }
    //1. 找到数组中的中间项，在原有的数组中把它移除
    let middleIndex = Math.floor(arr.length / 2)
    //删除的这一项数组的元素
    let middleValue = arr.splice(middleIndex, 1)[0]
    //2. 准备左右两个数组，循环剩下数组中的每一项，比当前项小的放在左边数组，比当前项大的放右边数组
    let arrLeft = []
    let arrRight = []
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i]
        item < middleValue ? arrLeft.push(item) : arrRight.push(item)
    }
    //3. 递归方式让左右两边的数组持续这样处理，一直到左右两边都排好序为止（最后让左边+中间+右边拼接成后的结果）
    return quick(arrLeft).concat(middleValue, quick(arrRight))
}
```

## 5. 实现防抖函数（debounce）

> 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。  

```javascript
function success (){
    console.log('提交成功');
}

/**
 * debounce 防抖函数
 * @param fn 需要修饰的函数
 * @param delay 时间
 */
// 防抖函数:限定多少时间之内只能执行一次
//1. 定义方法
const debounce=(fn,delay)=>{
    let timer=null
    //4. 把定时器返回给debounce
    return (...args)=>{
        //5. 清除上一次点击还没有执行的定时器
        clearTimeout(timer)
        //3. 设置定时器
        timer=setTimeout(() => {
            //实现this与参数的传递
            fn.apply(this,args)
        }, delay)
    }
}
//这个常量被赋值为经过debounce函数修饰后的success函数
//2. 调用方法
const oDebounce= debounce(success, 1000)
let btn=document.getElementById("btn")
btn.addEventListener('click', oDebounce)
```

## 6. 实现节流函数（throttle）
> 节流函数原理:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。  
```javascript

```

## 9. 实现instanceOf
```javascript
//模拟instance_of

/**
 * instance_of
 * @param {*} l 表示对象的原型
 * @param {*} r 表示类的原型
 */

function instance_of(left,right) {
    let prototype=right.prototype
    left=left.__proto__
    //判断对象的类型是否等于类的原型
    while(true){
        if(left=== null) return false
        if(left === o) return true
        left=left.__proto__
    }
//while循环里面为什么要加一句 l=left.__proto__
//第一次循环如果两个if都不满足的话，在结尾重新给left赋值
//第一次left=left.__proto__ 如果两个if都不满足的话left=left(此时的left就是left.__proto__).__proto__
//第二次的时候left=left.__proto__.__proto__
//然后一次次循环,left === left === prototype结束
}
```

## 10. 模拟new
```javascript
/**
 * new操作符做了哪些事情？
 * 1. 创建一个空对象
 * 2. 设置原型链
 * 3. 让this指向新创建的空对象，并且执行类的主体
 * 4. 判断返回值的类型，如果是值类型就返回新创建的对象，如果是引用类型，就返回这个引用类型的对象
 * //如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用
 */
/**
 * 
 * @param {*} obj 类
 * @param  {...any} args 剩余的参数
 */

function capyNew(obj,...args) {
    //1.创建一个空对象
     const newObj={};
     //2.让这个空对象的原型指向构造函数的prototype
     newObj.__proto=obj.prototype;
     //3.将obj的this改为新创建的这个对象
     let result=obj.apply(newObj,args)
     //4.判断类里面有返回值吗？返回值是对象吗?如果是的那那就返回类中的返回值，如果不是的话那就返回新创建的对象
     return typeof result === 'object' ? result : newObj
 }

//如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。（一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。
```