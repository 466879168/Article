# es6新特性
## 1. 变量声明let const
> let表示声明变量，const声明常量，两者都是块级作用域，const声明的常量值不会改变  
> 如果const是一个对象，那么对象里面的值也是可以更改的(对象所指的引用地址没有改变就行)  

+ let声明的变量没有变量提升特性
+ let和const声明的变量有块级作用域，只在最靠近的一个块中有效
+ 使用const声明时，大写变量
+ const在声明的时候必须赋值
+ let声明变量后可立马赋值或使用时赋值
+ 声明方法：var、const、let、function、class、import

1. 不允许重复声明
2. 未定义就使用会报错：const和let不存在变量提升
3. 暂时性死区：只要块级作用域内存在const和let，所声明常量和变量就绑定此区域，不再受外部影响

## 2. Symbol
+ 定义：独一无二的值
+ 声明：const set = Symbol(str)
+ 入参：字符串(可选)

1. Symbol()生成一个原始类型的值不是对象，因此Symbol()前不能使用new命令
2. Symbol()参数表示对当前Symbol值的描述，相同参数的Symbol()返回值不相等
3. Symbol值不能与其他类型的值进行运算
4. Symbol值可通过String()或toString()显式转为字符串
5. Symbol值作为对象属性名时，此属性是公开属性，但不是私有属性
6. Symbol值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取
7. Symbol值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法

## 3. Set
+ 定义：类似于数组的数据结构，成员值都是唯一且没有重复的值
+ 声明：const set = new Set(arr)
+ 入参：具有Iterator接口的数据结构
+ 属性
  + constructor：构造函数，返回Set
  + size：返回实例成员总数
+ 方法
  + add()：添加值，返回实例
  + delete()：删除值，返回布尔值
  + has()：检查值，返回布尔值
  + clear()：清除所有成员
  + keys()：返回以属性值为遍历器的对象
  + values()：返回以属性值为遍历器的对象
  + entries()：返回以属性值和属性值为遍历器的对象
  + forEach()：使用回调函数遍历每个成员

应用场景：  
+ 去重字符串：[...new Set(str)].join("")
+ 去重数组：[...new Set(arr)]或Array.from(new Set(arr))

重点：
1. 遍历顺序：插入顺序
2. 没有键只有值，可认为键和值两值相等
3. 添加多个NaN时，只会存在一个NaN
4. 添加相同的对象时，会认为是不同的对象
5. 添加值时不会发生类型转换(5 !== "5")
6. keys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等

## 4. Map
+ 定义：类似于对象的数据结构，成员键可以是任何类型的值
+ 声明：const set = new Map(arr)
+ 入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构
+ 属性
  + constructor：构造函数，返回Map
  + size：返回实例成员总数
+ 方法
  + get()：返回键值对
  + set()：添加键值对，返回实例
  + delete()：删除键值对，返回布尔值
  + has()：检查键值对，返回布尔值
  + clear()：清除所有成员
  + keys()：返回以键为遍历器的对象
  + values()：返回以值为遍历器的对象
  + entries()：返回以键和值为遍历器的对象
  + forEach()：使用回调函数遍历每个成员

重点：
1. 遍历顺序：插入顺序
2. 对同一个键多次赋值，后面的值将覆盖前面的值
3. 对同一个对象的引用，被视为一个键
4. 对同样值的两个实例，被视为两个键
5. 键跟内存地址绑定，只要内存地址不一样就视为两个键
6. 添加多个以NaN作为键时，只会存在一个以NaN作为键的值
7. Object结构提供字符串—值的对应，Map结构提供值—值的对应

## 5. 模板字符串
> 在es6之前处理模板字符串需要使用字符串拼接  
> 对于es6来说:

1. 基本的字符串格式化，将表达式嵌入到字符串中进行拼接，用${}来界定  
2. es6使用反引号来规定模板字符串

## 6. 箭头函数
> es6中箭头函数就是函数的一种简写方式，使用括号包括参数，然后跟随一个=>，紧接着就是函数体  

箭头函数最直接的几个特点：  
1. 不需要function关键字来创建函数
2. 可以省略return关键字
3. 没有自己的this，继承当前上下文的this关键字 

> 箭头函数内部的this总是指向定义时所在的对象。


> 注意：当函数只有一个参数的时候，是可以省略掉小括号的，当你函数返回有且仅有一个表达式的时候可以省略{}和return  

1. 函数体内的this是定义时所在的对象而不是使用时所在的对象
2. 可让this指向固定化，这种特性很有利于封装回调函数
3. 不可当作构造函数，因此箭头函数不可使用new命令
4. 不可使用yield命令，因此箭头函数不能用作Generator函数
5. 不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)
6. 返回对象时必须在对象外面加上括号

## 7. 函数的参数默认值  
```javascript
//es5 
function print(text){
text=text || 'default'
console.log(text)
}

//es6
function print (text='default'){
    console.log(text)
}
```

## 8. 对象函数增强写法
```javascript
let obj={
    type:type,
    age:age
}
//es6
let obj={
    type,age
}
//函数增强写法
let obj={
    demo:function(){

    }
}
//es6
let obj={
    demo(){

    }
}
```

## 9. ...运算符 
```javascript
//1. 展开运算符
let arr=[1,2,3]
let arr1=[0,...arr,4]
console.log(arr1)//(5) [0, 1, 2, 3, 4]

//2. 剩余运算符
let a=[1,2,3]
let [b,...c]=a
console.log(b)//1
console.log(c)//(2) [2, 3]
```

## 10. 解构赋值
```JavaScript
//分为对象和数组
var obj={
    name:'dylan',
    age:26,
    sex:'男'
}
//es5
let name=obj.name
let age=obj.age
let sex=obj.sex
console.log(name+'---'+age+'---'+sex)
//dylan---26---男

//es6
const {name,age,sex}=obj
console.log(name+'---'+age+'---'+sex)
//dylan---26---男


//数组
let arr=[1,2,3]
let [a,b,c]=arr
console.log(a,b,c)//1 2 3
```
应用场景  
1. 交换变量值：[x, y] = [y, x]
2. 返回函数多个值：const [x, y, z] = Func()
3. 定义函数参数：Func([1, 2])
4. 提取JSON数据：const { name, version } = packageJson
5. 定义函数参数默认值：function Func({ x = 1, y = 2 } = {}) {}
6. 遍历Map结构：for (let [k, v] of Map) {}
7. 输入模块指定属性和方法：const { readFile, writeFile } = require("fs")

## 11. for循环
> for...in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性(数组上定义的属性，数组原型上定义的属性，对象原型上定义的属性)  
> 
> for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，并为每个不同属性的值执行语句
> 
> 无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。  
> for...in 语句以任意顺序迭代对象的可枚举属性
> for...of 语句遍历可迭代对象定义要迭代的数据

1. 遍历字符串：for-in获取索引，for-of获取值
2. 遍历数组：for-in获取索引，for-of获取值
3. 遍历对象：for-in获取键，for-of需自行部署
4. 遍历Set：for-of获取值 => for (const v of set)
5. 遍历Map：for-of获取键值对 =>  for (const [k, v] of map)
6. 遍历类数组：包含length的对象、Arguments对象、NodeList对象(无Iterator接口的类数组可用Array.from()转换)
7. 

```javascript
Object.prototype.objCustom=function(){}
Array.prototype.ArrCustom=function(){}
let arr=[1,2,3]
arr.fn='hello'
for(let item in arr){
    console.log(item)//0(下标) 1(下标) 2(下标) fn ArrCustom objCustom
}
for(let item in arr){
    if(arr.hasOwnProperty(item)){
        console.log(item)//0 1 2 fn证明ArrCustom objCustom是属于原型上的属性
    }
}

for(let item of arr){
    console.log(item)// 1 2 3 
}
```

## 12. class
> es6中支持class语法，class语法不是新的对象继承模型，它只是原型链的语法糖表现形式

+ 定义：对一类具有共同特征的事物的抽象(构造函数语法糖)
+ 原理：类本身指向构造函数，所有方法定义在prototype上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)
+ 方法和关键字
  + constructor()：构造函数，new命令生成实例时自动调用
  + extends：继承父类
  + super：新建父类的this
  + static：定义静态属性方法
  + get：取值函数，拦截属性的取值行为
  + set：存值函数，拦截属性的存值行为



```javascript
class Student {
    //示例的属性
  constructor() {
    console.log("I'm a student.");
  }
 //实力可以访问
  study() {
    console.log('study!');
  }
 //添加static是构造函数自身的方法，示例不能访问
  static read() {
    console.log("Reading Now.");
  }
}
```

## 13. Proxy
+ 定义：修改某些操作的默认行为
+ 声明：const proxy = new Proxy(target, handler)
+ 入参
  + target：拦截的目标对象
  + handler：定制拦截行为
+ 方法
  + Proxy.revocable()：返回可取消的Proxy实例(返回{ proxy, revoke }，通过revoke()取消代理)
+ 拦截方式
  + get()：拦截对象属性读取
  + set()：拦截对象属性设置，返回布尔值
  + has()：拦截对象属性检查k in obj，返回布尔值
  + deleteProperty()：拦截对象属性删除delete obj[k]，返回布尔值
  + defineProperty()：拦截对象属性定义Object.defineProperty()、Object.defineProperties()，返回布尔值
  + ownKeys()：拦截对象属性遍历for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组
  + getOwnPropertyDescriptor()：拦截对象属性描述读取Object.getOwnPropertyDescriptor()，返回对象
  + getPrototypeOf()：拦截对象原型读取instanceof、Object.getPrototypeOf()、Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象
  + setPrototypeOf()：拦截对象原型设置Object.setPrototypeOf()，返回布尔值
  + isExtensible()：拦截对象是否可扩展读取Object.isExtensible()，返回布尔值
  + preventExtensions()：拦截对象不可扩展设置Object.preventExtensions()，返回布尔值
  + apply()：拦截Proxy实例作为函数调用proxy()、proxy.apply()、proxy.call()
  + construct()：拦截Proxy实例作为构造函数调用new proxy()

应用
+ Proxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问
+ get()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点
+ set()：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写
+ has()：隐藏内部属性不被发现、排除不符合属性条件的对象
+ deleteProperty()：保护内部属性不被删除
+ defineProperty()：阻止属性被外部定义
+ ownKeys()：保护内部属性不被遍历

重点：
1. 要使Proxy起作用，必须针对实例进行操作，而不是针对目标对象进行操作
2. 没有设置任何拦截时，等同于直接通向原对象
3. 属性被定义为不可读写/扩展/配置/枚举时，使用拦截方法会报错
4. 代理下的目标对象，内部this指向Proxy代理

## 14. Reflect
+ 定义：保持Object方法的默认行为
+ 方法
  + get()：返回对象属性
  + set()：设置对象属性，返回布尔值
  + has()：检查对象属性，返回布尔值
  + deleteProperty()：删除对象属性，返回布尔值
  + defineProperty()：定义对象属性，返回布尔值
  + ownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())
  + getOwnPropertyDescriptor()：返回对象属性描述，返回对象
  + getPrototypeOf()：返回对象原型，返回对象
  + setPrototypeOf()：设置对象原型，返回布尔值
  + isExtensible()：返回对象是否可扩展，返回布尔值
  + preventExtensions()：设置对象不可扩展，返回布尔值
  + apply()：绑定this后执行指定函数
  + construct()：调用构造函数创建实例

Proxy方法和Reflect方法一一对应  
Proxy和Reflect联合使用，前者负责拦截赋值操作，后者负责完成赋值操作

## 15. Module
+ 命令
  + 默认导入导出：export { default } from "person"
  + 整体导入导出：export * from "person"
  + 按需导入导出：export { age, name, sex } from "person"
  + 改名导入导出：export { name as newName } from "person"
  + 具名改默认导入导出：export { name as default } from "person"
  + 默认改具名导入导出：export { default as name } from "person"默认导入：import Person from "person"
  + 整体导入：import * as Person from "person"
  + 按需导入：import { age, name, sex } from "person"
  + 改名导入：import { name as newName } from "person"
  + 自执导入：import "person"
  + 复合导入：import Person, { name } from "person"
  + 默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)
  + 单独导出：export const name = "Bruce"
  + 按需导出：export { age, name, sex }(推荐)
  + 改名导出：export { name as newName }
  + export：规定模块对外接口
  + import：导入模块内部功能

## 16. Promise
+ 定义：包含异步操作结果的对象
+ 状态
  + 进行中：pending
  + 已成功：resolved
  + 已失败：rejected
+ 特点
  + 对象的状态不受外界影响
  + 一旦状态改变就不会再变，任何时候都可得到这个结果
+ 声明：new Promise((resolve, reject) => {})
+ 出参
  + resolve：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去
  + reject：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去
+ 方法
+ 